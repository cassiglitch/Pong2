<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden; /* No more scrolling for you! */
            background-color: #f0f0f0; /* Set a background color */
        }

        :root {
            --grid-size: 20px; /* Define the grid size variable */
        }

        #scoreDisplay {
            margin-top: calc(var(--grid-size) * 1.5); /* Adjust margin based on grid size */
            position: fixed;
            font-size: var(--grid-size); /* Set font size equal to grid size */
        }

        canvas {
            position: fixed;
            top: 0px; /* Adjust the top position as needed */
            bottom: 0px; /* Adjust the bottom position as needed */
            border: 1px solid #ddd;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Add a subtle shadow to the canvas */
        }
        body {
            overflow: hidden; /* Disable scrolling */
            touch-action: none; /* Disable touch actions on the canvas */
}
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background-color: #ff00ff; /* Purple color for confetti */
            opacity: 1; /* Fully visible */
            animation: confetti-fall 2s ease-out infinite; /* Confetti falling animation */
        }

        @keyframes confetti-fall {
            0% {
                top: -10px; /* Start above the canvas */
                transform: rotateZ(0deg); /* No rotation initially */
                opacity: 1; /* Fully visible */
            }
            100% {
                top: 100%; /* End below the canvas */
                transform: rotateZ(720deg); /* Rotation during fall */
                opacity: 0; /* Invisible */
            }
        }
        .cooldown-meter {
    width: 200px;
    height: 20px;
    background-color: #ddd;
    border-radius: 10px;
    overflow: hidden;
}

.cooldown-progress {
    width: 100%;
    height: 100%;
    background-color: #4CAF50;
    border-radius: 10px;
    transition: width 0.1s linear; /* Smooth transition */
}

    </style>
    <title>Snake Game</title>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/tinycolor2@1.4.2/dist/tinycolor-min.js"></script>
    <div id="scoreDisplay">Score: 0</div>
    <canvas id="snakeCanvas"></canvas>
        <div id="victoryMessage"></div>
    <div class="cooldown-meter">
    <div class="cooldown-progress"></div>
</div>

    <script>
        const canvas = document.getElementById('snakeCanvas');
        const ctx = canvas.getContext('2d');
let LaserChargeTime = 5
let cooldownDuration = LaserChargeTime * 1000; // Cooldown duration in milliseconds (7.5 seconds)
let cooldownStartTime = 0; // Timestamp of the cooldown start

const cooldownMeter = document.querySelector('.cooldown-progress');

function startCooldown() {
    cooldownStartTime = Date.now();

    // Start the cooldown animation
    cooldownMeter.style.transition = `width ${cooldownDuration}ms linear`;
    cooldownMeter.style.width = '0'; // Reset progress bar width

    // Update the cooldown progress
    updateCooldown();
}

function updateCooldown() {
    const currentTime = Date.now();
    const elapsedTime = currentTime - cooldownStartTime;
    const remainingTime = cooldownDuration - elapsedTime;

    // Calculate the remaining cooldown percentage
    const cooldownPercentage = Math.max(0, (remainingTime / cooldownDuration) * 100);

    // Update the progress bar width
    cooldownMeter.style.width = `${cooldownPercentage}%`;

    if (remainingTime > 0) {
        // Continue updating the cooldown progress
        requestAnimationFrame(updateCooldown);
    } else {
        // Cooldown has ended, reset progress bar
        cooldownMeter.style.width = '100%';
    }
}


        let lives = 0.5
        let maxscore = 100;
        let startingGridSize = 20;
        let gridSize = 20;
        let startingLength = 5;
        let snake = Array.from({ length: startingLength }, (_, index) => ({ x: 10, y: 10 - index, color: 'green' }));
        let food = { x: 0, y: 0 };
        let obstacles = [];
        let dynamicObstacles = [];
        let direction = 'right';
        let score = 0;
        let isEating = false;
        let eatingAnimationFrames = 0;
        let isInvincible = false;
        let invincibilityDuration = 0;
        let isColliding = false;
        let collisionAnimationFrames = 10;
        let isPaused = false;
        let originalSnakeColor = '#00FF00';
var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
        

const laser = {
    isShooting: false,
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    width: 20 // Width of the laser (in pixels)
};


function checkCollision(x1, y1, x2, y2, x3, y3, x4, y4) {
    const uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
    const uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

    return uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1;
}

// Handle tap events for shooting the laser
let tapStartX = 0;
let tapStartY = 0;
let tapEndX = 0;
let tapEndY = 0;

function handleTapStart(event) {
    tapStartX = event.touches[0].clientX;
    tapStartY = event.touches[0].clientY;
}

function handleTapEnd(event) {
    tapEndX = event.changedTouches[0].clientX;
    tapEndY = event.changedTouches[0].clientY;

    // Calculate the distance between start and end points
    const deltaX = Math.abs(tapEndX - tapStartX);
    const deltaY = Math.abs(tapEndY - tapStartY);

    // If the distance is small enough, treat it as a tap
    if (deltaX < 10 && deltaY < 10) {
        // Only shoot the laser if it's not already shooting
        if (!laser.isShooting) {
            const canvasRect = canvas.getBoundingClientRect();
            const canvasX = tapEndX - canvasRect.left;
            const canvasY = tapEndY - canvasRect.top;
            shootLaser(canvasX, canvasY);
        }
    }
}

canvas.addEventListener('touchstart', handleTapStart);
canvas.addEventListener('touchend', handleTapEnd);


// Drawing function to draw the laser with fade effect
function drawLaser() {
    if (laser.isShooting) {
        // Calculate the alpha value for the fade effect
        const currentTime = Date.now();
        const elapsedTime = currentTime - laserStartTime;
        let alpha = 1 - (elapsedTime / 5000); // Fade out over 5 seconds
        alpha = Math.max(0, alpha); // Ensure alpha is not negative

        // Set the stroke style with alpha
        ctx.beginPath();
        ctx.lineWidth = laser.width;
        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`; // Color of the laser with alpha
        ctx.moveTo(laser.x1, laser.y1);
        ctx.lineTo(laser.x2, laser.y2);
        ctx.stroke();
    }
}

let lastLaserShot = 0; // Timestamp of the last laser shot
const laserCooldown = LaserChargeTime * 1000; // Cooldown period in milliseconds (30 seconds)

// Function to handle shooting the laser
function shootLaser(targetX, targetY) {
    const currentTime = new Date().getTime();

    // Check if the cooldown period has elapsed
    if (currentTime - lastLaserShot < laserCooldown) {
        return; // Laser is still on cooldown
    } else {
        isShooting = true;

        // Calculate the angle and distance to the canvas edge
        const snakeHeadX = snake[0].x * gridSize;
        const snakeHeadY = snake[0].y * gridSize;
        const dx = targetX - snakeHeadX;
        const dy = targetY - snakeHeadY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);

        // Calculate the end point of the laser
        const endX = snakeHeadX + Math.cos(angle) * canvas.width;
        const endY = snakeHeadY + Math.sin(angle) * canvas.height;

        // Draw the laser
        ctx.beginPath();
        ctx.moveTo(snakeHeadX, snakeHeadY);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 20;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Check for collision with obstacles
        checkLaserCollision();

        // After 5 seconds, reset the shooting state and clear the laser
        setTimeout(() => {
            isShooting = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }, 5000);

        // Update the timestamp of the last laser shot
        lastLaserShot = currentTime;
    }
}


// Updated laser collision detection
function checkLaserCollision() {
    const snakeHeadX = snake[0].x * gridSize;
    const snakeHeadY = snake[0].y * gridSize;
    const dx = targetX - snakeHeadX;
    const dy = targetY - snakeHeadY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);

    // Define laser beam parameters
    const laserWidth = 20; // Width of the laser beam
    const laserLength = distance; // Length of the laser beam
    const laserStartX = snakeHeadX;
    const laserStartY = snakeHeadY;
    const laserEndX = targetX;
    const laserEndY = targetY;

    // Iterate through obstacles for collision detection
    obstacles.forEach((obstacle, index) => {
        // Check if the bounding boxes of the laser and obstacle intersect
        if (boundingBoxesIntersect(laserStartX, laserStartY, laserEndX, laserEndY, obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize)) {
            // Perform detailed intersection detection
            if (laserIntersectsObstacle(laserStartX, laserStartY, laserEndX, laserEndY, obstacle)) {
                // Remove the obstacle from the array
                obstacles.splice(index, 1);
            }
        }
    });
}

// Function to check if the bounding boxes of two objects intersect
function boundingBoxesIntersect(x1, y1, x2, y2, rx, ry, rw, rh) {
    return x1 < rx + rw &&
        x1 + laserWidth > rx &&
        y1 < ry + rh &&
        y1 + laserWidth > ry;
}

// Function to check if the laser intersects with an obstacle
function laserIntersectsObstacle(laserStartX, laserStartY, laserEndX, laserEndY, obstacle) {
    // Vector representing the laser beam
    const laserVector = { x: laserEndX - laserStartX, y: laserEndY - laserStartY };

    // Iterate through each edge of the obstacle
    for (let i = 0; i < obstacle.edges.length; i++) {
        const edge = obstacle.edges[i];
        const edgeStartX = edge[0].x * gridSize;
        const edgeStartY = edge[0].y * gridSize;
        const edgeEndX = edge[1].x * gridSize;
        const edgeEndY = edge[1].y * gridSize;

        // Vector representing the obstacle edge
        const obstacleVector = { x: edgeEndX - edgeStartX, y: edgeEndY - edgeStartY };

        // Calculate the intersection point between the laser beam and the obstacle edge
        const intersectionPoint = calculateIntersectionPoint(laserStartX, laserStartY, laserVector, edgeStartX, edgeStartY, obstacleVector);

        // Check if the intersection point is within the bounds of the obstacle edge
        if (intersectionPoint && isPointOnLineSegment(intersectionPoint.x, intersectionPoint.y, edgeStartX, edgeStartY, edgeEndX, edgeEndY)) {
            // Collision detected, remove the obstacle
            return true;
        }
    }

    return false;
}

// Function to calculate the intersection point between two vectors
function calculateIntersectionPoint(start1X, start1Y, vector1, start2X, start2Y, vector2) {
    const den = vector1.x * vector2.y - vector1.y * vector2.x;
    if (den === 0) {
        return null; // Vectors are parallel
    }

    const t = ((start2X - start1X) * vector2.y - (start2Y - start1Y) * vector2.x) / den;
    const u = -((start1X - start2X) * vector1.y - (start1Y - start2Y) * vector1.x) / den;

    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
        // Calculate intersection point coordinates
        const intersectionX = start1X + t * vector1.x;
        const intersectionY = start1Y + t * vector1.y;
        return { x: intersectionX, y: intersectionY };
    } else {
        return null; // Intersection point lies outside the vectors
    }
}

// Function to check if a point lies on a line segment
function isPointOnLineSegment(pointX, pointY, lineStartX, lineStartY, lineEndX, lineEndY) {
    const minX = Math.min(lineStartX, lineEndX);
    const maxX = Math.max(lineStartX, lineEndX);
    const minY = Math.min(lineStartY, lineEndY);
    const maxY = Math.max(lineStartY, lineEndY);

    return pointX >= minX && pointX <= maxX && pointY >= minY && pointY <= maxY;
}
// Function to check if a line segment intersects with a rectangle
function lineIntersectsRect(x1, y1, x2, y2, rx, ry, rw, rh) {
    // Check if any of the line segment end points are inside the rectangle
    if ((x1 >= rx && x1 <= rx + rw && y1 >= ry && y1 <= ry + rh) ||
        (x2 >= rx && x2 <= rx + rw && y2 >= ry && y2 <= ry + rh)) {
        return true;
    }

    // Check if any of the rectangle's edges intersect with the line segment
    const topIntersects = lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx + rw, ry);
    const bottomIntersects = lineIntersectsLine(x1, y1, x2, y2, rx, ry + rh, rx + rw, ry + rh);
    const leftIntersects = lineIntersectsLine(x1, y1, x2, y2, rx, ry, rx, ry + rh);
    const rightIntersects = lineIntersectsLine(x1, y1, x2, y2, rx + rw, ry, rx + rw, ry + rh);

    return topIntersects || bottomIntersects || leftIntersects || rightIntersects;
}

// Function to check if two line segments intersect
function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
    const den = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (den === 0) {
        return false;
    }

    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / den;
    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / den;

    return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
}

// Function to pause the game
function pauseGame() {
    isPaused = !isPaused; // Toggle the paused state
}

// Event listener to call the pauseGame function when the 'p' key is pressed

function draw() {
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Layer 1: Draw Invincibility Aura
    if (isInvincible) {
        drawInvincibilityAura();
    }

    // Layer 2: Draw Snake Body
    snake.forEach((segment, index) => {
        ctx.fillStyle = segment.color;
        ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
    });

    // Layer 3: Draw Snake Head
    const head = snake[0];
    ctx.fillStyle = 'lightgreen'; // Head color
    ctx.fillRect(head.x * gridSize, head.y * gridSize, gridSize, gridSize);

    // Draw Food
            ctx.fillStyle = getFoodColor(food.type);
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

    // Layer 4: Draw Eating Animation
    if (isEating) {
        drawEatingAnimation();
    }

    // Layer 5: Draw Obstacles
    ctx.fillStyle = 'black';
    obstacles.forEach(obstacle => ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize));

    // Draw Dynamic Obstacles
    ctx.fillStyle = 'grey';
    dynamicObstacles.forEach(obstacle => {
        ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize * 2, gridSize * 2);
    });

    // Draw Score
    const scoreDisplay = document.getElementById('scoreDisplay');
    scoreDisplay.textContent = `Score: ${score}`;

    
    drawLaser();
}

function drawInvincibilityAura() {
        getZoomFactor()
    var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
        snake.forEach((segment, index) => {
        ctx.fillStyle = 'rgba(255, 165, 0, 0.3)'; // Orange color with transparency
        let shadowSize = Math.max(0, Math.ceil(10 * antiZoomFactor));
        ctx.fillRect(segment.x * gridSize - shadowSize, segment.y * gridSize - shadowSize, gridSize + shadowSize * 2, gridSize + shadowSize * 2);
    });
}

function drawEatingAnimation() {
    getZoomFactor()
    var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
    const animationColor = 'rgba(0, 0, 255, 0.5)'; // Blue color with transparency
    let segmentSize = gridSize; // Adjust segment size based on anti-zoom factor
    let waveSize = 5; // Adjust the size of the wave based on anti-zoom factor
    let maxFrames = 8; // Number of frames for the eating animation

    let head = snake[0];
    let eatenSegments = snake.slice(1, eatingAnimationFrames + 1);
eatenSegments.forEach((segment, index) => {
    let animationFrame = eatingAnimationFrames - index;
    const segmentX = segment.x * gridSize;
    const segmentY = segment.y * gridSize;

    let originalOffset = waveSize * (maxFrames - animationFrame);
    var scaledOffset = Math.max(0, Math.ceil(originalOffset * antiZoomFactor));

    // Draw the wave-like effect
    ctx.fillStyle = animationColor;
    ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
    ctx.fillRect(segmentX - scaledOffset, segmentY, segmentSize, segmentSize);
    ctx.fillRect(segmentX + scaledOffset, segmentY, segmentSize, segmentSize);
    ctx.fillRect(segmentX, segmentY - scaledOffset, segmentSize, segmentSize);
    ctx.fillRect(segmentX, segmentY + scaledOffset, segmentSize, segmentSize);

    // Draw the original segment
    ctx.fillRect(segmentX, segmentY, segmentSize, segmentSize);
});

originalSnakeColor = '#00FF00'; // Reset snake color after eating animation
}


        function getFoodColor(foodType) {
            switch (foodType) {
                case 'normal':
                    return 'red';
                case 'superfood':
                    return 'gold';
                case 'poison':
                    return 'purple';
                case 'teleport':
                    return 'blue';
                case 'invincibility':
                    return 'orange';
            }
        }

// Function to trigger invincibility
function HaHaNoCollision(duration) {
    isInvincible = true;
    invincibilityDuration = duration; // Set the duration for invincibility
}

        function update() {
            // If the snake is invincible, decrement the invincibility duration
            if (isInvincible) {
                invincibilityDuration--;
                // If the invincibility duration has expired, reset the invincibility status
                if (invincibilityDuration <= 0) {
                    isInvincible = false;
                }
            }

            // Update Snake position
            const head = { ...snake[0] };
            switch (direction) {
                case 'up':
                    head.y = (head.y - 1 + canvas.height / gridSize) % (canvas.height / gridSize);
                    break;
                case 'down':
                    head.y = (head.y + 1) % (canvas.height / gridSize);
                    break;
                case 'left':
                    head.x = (head.x - 1 + canvas.width / gridSize) % (canvas.width / gridSize);
                    break;
                case 'right':
                    head.x = (head.x + 1) % (canvas.width / gridSize);
                    break;
            }

   if (!isInvincible && (obstacles.some(obstacle => obstacle.x === head.x && obstacle.y === head.y) ||
        dynamicObstacles.some(obstacle => (head.x >= obstacle.x && head.x < obstacle.x + 2) &&
            (head.y >= obstacle.y && head.y < obstacle.y + 2)))) {
        isColliding = true;
        collisionAnimationFrames = 10;
        
        // Decrement segments (lives) by 5%
        const numSegmentsToRemove = Math.ceil(snake.length * lives);
        if (snake.length > numSegmentsToRemove) {
            snake.splice(0, numSegmentsToRemove);
            lives = (lives * 2);
        } else {
            restartGame(); // End the game if segments (lives) run out
            return;
        }
        
        // Apply invincibility and reset if there are remaining segments (lives)
        isInvincible = true;
        invincibilityDuration = 7.5; // Set the duration for invincibility
        return;
    }

            // Check if Snake eats Food
            if (head.x === food.x && head.y === food.y) {
                if (food.type === 'superfood') {
                    score += 2;
                    snake.unshift({ ...snake[0], color: 'blue' });
                    snake.unshift({ ...snake[0], color: 'blue' });
                } else if (food.type === 'poison') {
                    if (snake.length < 4) {
                        restartGame();
                        return;
                    }
                    snake.pop();
                    snake.pop();
                    snake.pop();
                    score = Math.max(0, Math.ceil(score / 2)); // Reduce score by 50% rounded up
                } else if (food.type === 'teleport') {
    // Teleport the snake to a random location
    const randomX = Math.floor(Math.random() * (canvas.width / gridSize));
    const randomY = Math.floor(Math.random() * (canvas.height / gridSize));
    head.x = randomX;
    head.y = randomY;

    // Randomize the direction
    const directions = ['up', 'down', 'left', 'right']; // Possible directions
    const randomIndex = Math.floor(Math.random() * directions.length);
    direction = directions[randomIndex];
    HaHaNoCollision(10)
                } else if (food.type === 'invincibility') {
HaHaNoCollision(50)
                } else {
                    score += 1;
                    snake.unshift({ ...snake[0], color: 'blue' });
                }
                isEating = true;
                eatingAnimationFrames = 8; // Set the number of frames for the eating animation
                spawnFood();

                // More frequent black blocks as score increases
                if (Math.random() < calculateObstacleSpawnProbability()) {
                    spawnObstacle();
                }
            }

    if (!isPaused) { // Check if the game is not paused
        // Move Snake
        snake.pop();
        snake.unshift(head);

        // Move Dynamic Obstacles
        dynamicObstacles.forEach(obstacle => {
            if (obstacle.id === 1) {
                // Left to right movement
                obstacle.x += 0.25;
                if (obstacle.x + 1 > canvas.width / gridSize) {
                    obstacle.x = 0; // Reset to the left side if it goes beyond the canvas boundary
                }
            } else if (obstacle.id === 2) {
                // Up and down movement
                obstacle.y += 0.25;
                if (obstacle.y + 1 > canvas.height / gridSize) {
                    obstacle.y = 0; // Reset to the top if it goes beyond the canvas boundary
                }
            }
        });
    }

            // Check for victory
            if (score >= maxscore) {
                declareVictory();
            }
if (laser.isShooting) {
        obstacles.forEach((obstacle, index) => {
            // Check if the laser intersects with the obstacle
            if (checkCollision(laser.x1, laser.y1, laser.x2, laser.y2, obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize)) {
                // If there's a collision, remove the obstacle from the array
                obstacles.splice(index, 1);
            }
        });
    }
    }

        function calculateObstacleSpawnProbability() {
            // Obstacle spawn probability increases with score
            return Math.min(0.1 + score / 200, 1); // Adjust the maximum spawn probability as needed
        }

        function spawnFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * (canvas.width / gridSize)),
                    y: Math.floor(Math.random() * (canvas.height / gridSize)),
                    type: generateFoodType()
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
                obstacles.some(obstacle => obstacle.x === newFood.x && obstacle.y === newFood.y) ||
                dynamicObstacles.some(obstacle => (newFood.x >= obstacle.x && newFood.x < obstacle.x + 1) &&
                    (newFood.y >= obstacle.y && newFood.y < obstacle.y + 1)));

            food = newFood;
        }

        function generateFoodType() {
            // Adjust the probability for different types of food as needed
            const random = Math.random();
            if (random === 0.1) {
                return 'invincibility';
            } else if (random <= 0.2) {
                return 'superfood';
            } else if (random <= 0.21) {
                return 'poison';
            } else if (random <= 0.3) {
                return 'teleport';
            } else {
                return 'normal';
            }
        }

        function spawnObstacle() {
            const x = Math.floor(Math.random() * (canvas.width / gridSize));
            const y = Math.floor(Math.random() * (canvas.height / gridSize));

            if (Math.random() < 0.5) {
                obstacles.push({ x: x, y: y });
            } else {
                // Randomly assign an ID to the dynamic obstacle
                const id = Math.random() < 0.5 ? 1 : 2;
                dynamicObstacles.push({ x: x, y: y, id: id });
            }
        }

        function restartGame() {
            pauseGame();
            createParticles(['red', orange]);
            animateExplosion();
            pauseGame();
            snake = Array.from({ length: startingLength }, (_, index) => ({ x: 10, y: 10 - index, color: 'green' }));
            obstacles = [];
            dynamicObstacles = [];
            score = 0;
            lives = 0.5;
            isEating = false;
            eatingAnimationFrames = 0;
            spawnFood();
        }

 

        function declareVictory() {
            pauseGame()
            createParticles(['gold', 'green']);
            animateExplosion();
            createShockwave()
            pauseGame()
            restartGame();
        }
        let particles = [];
const numParticles = 200;
const explosionForce = 50;
const holeSize = 20;

// Function to calculate the X position of the snake's head
function getSnakeHeadX() {
    return snake[0].x * gridSize + gridSize / 2;
}

// Function to calculate the Y position of the snake's head
function getSnakeHeadY() {
    return snake[0].y * gridSize + gridSize / 2;
}

// Modify the Particle constructor to accept head position parameters and an array of colors
function Particle(x, y, radius, colors, headX, headY) {
    this.x = x + headX; // Calculate the particle's position relative to the snake's head
    this.y = y + headY;
    this.radius = radius;
    this.colors = colors; // Array of color names
    this.color = this.colors[Math.floor(Math.random() * this.colors.length)]; // Randomly select a color from the array
    this.velocity = {
        x: (Math.random() - 0.5) * explosionForce * (Math.random() * 2),
        y: (Math.random() - 0.5) * explosionForce * (Math.random() * 2)
    };
    this.alpha = 1;
    this.update = function() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.alpha -= 0.01;
        this.draw();
    };
    this.draw = function() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
        ctx.fillStyle = this.color; // Use the selected color
        ctx.fill();
        ctx.restore();
    };
}

// Modify the createParticles function to pass head position parameters and an array of color names
function createParticles(colorNames) {
    const headX = getSnakeHeadX();
    const headY = getSnakeHeadY();
    for (let i = 0; i < numParticles; i++) {
        const randomColorName = colorNames[Math.floor(Math.random() * colorNames.length)]; // Randomly select a color name from the array
        const color = tinycolor(randomColorName).toHexString(); // Convert color name to hexadecimal color code
        const particle = new Particle(0, 0, 5, color, headX, headY);
        particles.push(particle);
    }
}

function simulateHoles(color) {
    ctx.fillStyle = color; // Use the color passed as a parameter
    particles.forEach(particle => {
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, holeSize, 0, Math.PI * 2);
        ctx.fill();
    });
}

function animateExplosion() {
    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update and draw particles
    particles.forEach((particle, index) => {
        particle.update();
        if (particle.alpha <= 0) {
            particles.splice(index, 1);
        }
    });

    // Simulate holes with the color of the particles
    simulateHoles(particles[0].color); // Pass the color of the first particle

    // Request animation frame
    if (particles.length > 0) {
        requestAnimationFrame(animateExplosion);
    }
}

// Function to create shockwave at the center of the explosion
function createShockwave() {
    const headX = getSnakeHeadX();
    const headY = getSnakeHeadY();
    
    ctx.beginPath();
    ctx.arc(headX, headY, 50, 0, Math.PI * 2);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 3;
    ctx.stroke();
}

// Call the functions to initiate the explosion animation
createParticles(['gold', 'red', 'blue']); // Example with multiple colors
animateExplosion();
createShockwave();



        function gameLoop() {
            resizeCanvas(); // Resize the canvas on every game loop iteration
            resizeCanvasHeight();
            update();
            draw();

            // Handle eating animation
            if (isEating) {
                eatingAnimationFrames--;

                // Apply the wavelike animation
                for (let i = 1; i < snake.length; i++) {
                    if (i <= eatingAnimationFrames) {
                        snake[i].color = 'blue';
                    } else {
                        snake[i].color = 'green';
                    }
                }

                if (eatingAnimationFrames === 0) {
                    isEating = false;
                }
            }
        }

function closestNumber(n, m) {
    // Find the quotient
    let q = Math.floor(n / m);

    // 1st possible closest number
    let n1 = m * q;

    // 2nd possible closest number
    let n2 = m * (q + 1);

    // Ensure that n1 does not exceed n
    if (n1 > n) {
        return n;
    }

    // Ensure that n2 does not exceed n
    if (n2 > n) {
        return n1;
    }

    // Return the closest multiple of m to n
    return Math.abs(n - n1) < Math.abs(n - n2) ? n1 : n2;
}

function resizeCanvas() {
    const canvasWidth = closestNumber(window.innerWidth, gridSize);
    const canvasHeight = closestNumber(window.innerHeight, gridSize);

    // Set canvas width and height
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // Adjust food position if it's out of bounds
    if (food.x >= canvasWidth / gridSize) {
        food.x = canvasWidth / gridSize - 1;
    }
    if (food.y >= canvasHeight / gridSize) {
        food.y = canvasHeight / gridSize - 1;
    }
}


// Handle arrow key presses
document.addEventListener('keydown', event => {
    // Prevent default arrow key behavior (scrolling)
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
        event.preventDefault();
    }

    if (!isPaused) {
        switch (event.key) {
            case 'ArrowUp':
                direction = 'up';
                break;
            case 'ArrowDown':
                direction = 'down';
                break;
            case 'ArrowLeft':
                direction = 'left';
                break;
            case 'ArrowRight':
                direction = 'right';
                break;
        }
    }
});

// Handle touch events for mobile controls
let touchStartX = 0;
let touchStartY = 0;

function handleTouchStart(event) {
    touchStartX = event.touches[0].clientX;
    touchStartY = event.touches[0].clientY;
}

function handleTouchEnd(event) {
    const touchEndX = event.changedTouches[0].clientX;
    const touchEndY = event.changedTouches[0].clientY;

    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;

    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Horizontal swipe
        direction = deltaX > 0 ? 'right' : 'left';
    } else {
        // Vertical swipe
        if (Math.abs(deltaY) > 10) {
            direction = deltaY > 0 ? 'down' : 'up';
        } 
    }

    // Perform actions based on direction if needed
}

canvas.addEventListener('touchstart', handleTouchStart);
canvas.addEventListener('touchend', handleTouchEnd);

        // Start the game loop
        const gameInterval = setInterval(gameLoop, 100); // Adjust the interval as needed

        function getZoomFactor() {
            var deviceWidth, landscape = Math.abs(window.orientation) == 90
            // workaround for strange screen.height on the iPhone (v3.1.3)
            if (window.screen.width == 320) deviceWidth = landscape ? 480 : 320
            else deviceWidth = window.screen[landscape ? "height" : "width"]
            var zoomFactor = deviceWidth / window.innerWidth;
            var antiZoomFactor = 1 / zoomFactor;
          
            // Apply zoom and anti-zoom factors to grid size
            gridSize = Math.max(0, Math.ceil(startingGridSize * antiZoomFactor));
            document.getElementById('scoreDisplay').style.top = (20 * antiZoomFactor) + 'px';
            document.documentElement.style.setProperty('--grid-size', (20 * antiZoomFactor) + 'px');
            
        }

        setInterval(getZoomFactor, 1); // Adjust the interval as needed

        // Clean up the interval when the window is closed
        window.addEventListener('beforeunload', () => {
            clearInterval(gameInterval);
        });
// Function to resize the canvas height based on viewport height
function resizeCanvasHeight() {
    const windowHeight = window.innerHeight; // Get the viewport height
    const canvasHeight = closestNumber(window.innerHeight, gridSize);; // Adjust the canvas height to be a multiple of gridSize
    canvas.height = canvasHeight; // Set the canvas height
}

// Call the resizeCanvasHeight function initially to set the canvas height
resizeCanvasHeight();

// Call the resizeCanvasHeight function whenever the window is resized
window.addEventListener('resize', resizeCanvasHeight);

                function adjustForZoom() {
            // Calculate the zoom factor
            const zoomFactor = window.innerWidth / window.screen.availWidth;
            // Adjust the grid size based on the zoom factor
            document.documentElement.style.setProperty('--grid-size', (20 * antiZoomFactor) + 'px');
            // Adjust the position of the score display
            const scoreDisplay = document.getElementById('scoreDisplay');
            scoreDisplay.style.marginTop = `calc(var(--grid-size) * antiZoomFactor)`;
            scoreDisplay.style.fontSize = `var(--grid-size)`;
        }
window.addEventListener('resize', getZoomFactor);
        // Call the adjustForZoom function initially and on window resize
        window.addEventListener('resize', adjustForZoom);
        adjustForZoom();
        
    </script>
</body>
</html>
